1. 编译阶段
    - 首先编写一个JavaFileObject类负责封装源码与编译后的字节码
        - 重写getCharContent 让其内部调用，返回源码
        - 重写openOutputStream 让其内部调用，创建一个新的字节数组输出流并返回，让其将编译好的字节码放在里面
    - 使用concurrentHashMap存储所有的JavaFileObject对象
    - 编写一个JavaFileManager类，重写getJavaFileForInput 和 getJavaFileForOutput
        - getJavaFileForInput负责取出concurrentHashmap中的JavaFileObject
        - getJavaFileForOutput负责封装JavaFileObject，放入concurrentHashmap中
    - 将源代码封装成JavaFileObject
    - 使用ToolProvider.getSystemJavaCompiler()的getTask方法进行编译
        - 首先，要得到源码才能进行编译，所以会调用 JavaFileObject 的 getCharContent 方法，得到源码的字符序 CharSequence；
        - 然后，编译器会对得到的源码进行编译，得到字节码，并且会将得到的字节码封装进一个 JavaFileObject 对象；
        - 编译器会把字节码结果存入一个 JavaFileObject 中，这个操作是需要创建一个 JavaFileObject 对象的，可是我们用来真实存储源码和字节码的 JavaFileObject 对象是我们自己写的，那么编译器如何得知它应该把编译生成的字节码放入一个怎样的 JavaFileObject 中呢?
        - 这时就要轮到 JavaFileManager 出场了，编译器会调用我们传入的 JavaFileManager fileManager 的 getJavaFileForOutput 方法，这个方法会 new 一个我们写的 TmpJavaFileObject 对象，并把返回给编译器；
        - 接下来，编译器会把生成的字节码放在 TmpJavaFileObject 对象中，存放的位置是由我们自己指定的，在 TmpJavaFileObject 中加入一个 ByteArrayOutputStream 属性用于存储字节码，编译器会通过 openOutputStream() 来创建输出流对象，并把这个用来存储字节的容器返回给编译器，让它把编译生成的字节码放进去；
        - 最后，我们想要的是 byte[] 字节数组，而非一个输出流，只要再在 TmpJavaFileObject 中加入一个 getCompiledBytes() 方法将 ByteArrayOutputStream 中的内容变成 byte[] 返回即可。

2. 运行阶段
    - 1. 使用ClassModifier，将concurrentHashMap中的JavaFileObject中的字节码中的java/lang/System java/util/Scanner改掉
        - 1.1 创建新的System类，
            - System类负责 控制台与程序之间的输入输出流的控制；数组的复制；并且公有的属性有 3 个，即标准输入流，标准输出流和标准错误流：
            - 因此我们需要将标准输入流换为我们的自定义输入流，标准输出流和标准错误流共用我们的自定义标准输出流
            - 直接编写此类，有些方法如setIn setErr setOut gc 等方法为了安全考虑，就静止使用（直接抛异常）
            - 同时编写getBufferString 获取当前线程的输出流中的内容
            - 同时编写closeBuffer 关闭当前线程的输入流和输出流
            - 正常的类，如system.copy则直接复制原方法，开放给用户
        - 1.2 创建自定义输入流HackInputStream()
            - 唯一的功能就是为每一个线程都保持一个标准输入流
            - 继承InputStream并重写个别方法
            - 重写get set，分别为向输入流放数据和取数据
            - 重写close，关闭流
        - 1.3 创建自定义打印流HackPrintStream()
            - 继承 PrintStream 类并重写 PrintStream 的所有公有方法，
            - 封装ThreadLocal<ByteArrayOutputStream> 实现线程封闭
            - 重写write print（前两个都是写） toString（这个是读） 
               - PrintStream 中有许多 print 方法，这些 print 的方法会将想要打印进它所装饰的输出流的内容写入，这些方法一般都是通过调用 PrintStream 中的各种 write 方法实现的。
            - 重写flush close，这些方法都是操作线程独占的outputstream
            - 重写error相关：setError  clearError checkError也都是操作线程独占的trouble的flag
        - 1.4 创建自定义Scanner---HackScanner
            - 该类整个复制 Scanner 类，唯一的区别在于修改一下这个构造函数 HackScanner(InputStream source)， 判断一下输入的 InputStream 是不是 我们自己写的HackInputStream()，
            如果是就调用一下它的 get 方法，把当前线程的输入流从 ThreadLocal 中取出来转化为reader后传给构造函数
        - 1.5 开始替换编译后的字节码
            - java的字节码中前4个字节是魔数，后4个字节是版本号，从第 9 个字节开始，就是常量池的入口
            - 常量池开始的两个字节，标识常量池中常量的数量 cpc (**constant_pool_count**)，计数从1开始，0空了出来，为了满足后面某些指向常量池的索引值的数据在特定情况下需要表达“不引用任何一个常量池项目”时，将让这个索引值指向 0 即可。
            - Java字节码的UTF-8常量信息（CONSTANT_Utf8_info）的格式是三段式，tag  当前常量的长度 len 常量的符号引用的字符串值 
            - 我们根据tag判断是否为1，如果不是1则直接跳过对应的常量（常量池中11种常量的长度是固定的）
            - 如果tag是1，则继续读取后面两个字节为常量的符号引用的字符串值的长度，根据这个长度即可读取到字符串值的内容，如果是java/lang/System java/util/Scanner则替换，如果不是则跳过继续判断
            - 因为这里是符号引用，还未经过类装载的链接中的装载阶段，所以肯定只有一个符号引用（字符串），所以直接替换即可。
    - 2. 将所有的JavaFileObject中的字节码中的modifiedBytes改掉后存在map中
    - 3. 设置用户传入的标准输入（这里set其实是set到system的threadLocal中的输入流中，所以是直接放到system类里的）
    - 4. new一个类加载器，把字节数组加载为Class对象
        - 重写findClass方法，根据类名直接从第2步生成的map中取修改后的字节码，然后调用defineClass函数进行加载即可
        - 代码中直接调用loadClass，传入主类名，加载某个类，如它所使用的类没有加载，则继续加载未加载的类
        - 最终生成主类的Class对象
    - 5. 通过反射调用Class对象的main方法